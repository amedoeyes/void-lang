// Construct a list from range
let range = start -> end ->
    if start > end then []
    else start : range (start + 1) end;

// Map list into a new list
let map = f -> l ->
	if l == [] then []
	else (f (head l)) : (map f (tail l));

// Filter elements that satisfy a predicate
let filter = pred -> l ->
	if l == [] then []
	else if pred (head l)
		 then head l : (filter pred (tail l))
		 else filter pred (tail l);

// Fold left
let foldl = f -> acc -> l ->
	if l == [] then acc
	else foldl f (f acc (head l)) (tail l);

let foldr = f -> acc -> l ->
	if l == [] then acc
	else f (head l) (foldr f acc (tail l));

// Get the length of a list
let length = l ->
	foldl (acc -> _ -> acc + 1) 0 l;

// Reverse a List
let reverse = l ->
	foldl (acc -> x -> x : acc) [] l;

// Append two lists
let append = l1 -> l2 ->
	foldl (acc -> x -> acc ++ [x]) l1 l2;

// Concatenate a list of lists
let concat = ll ->
	foldl (acc -> l -> append acc l) [] ll;

// Check if any element satisfies a predicate
let any = pred -> l ->
	foldl (acc -> x -> acc || pred x) false l;

// Check if all elements satisfy a predicate
let all = pred -> l ->
	foldl (acc -> x -> acc && pred x) true l;

// Check if an element exists in a list
let elem = x -> l ->
	any (y -> y == x) l;

// Map list and then flatten it
let flat_map = f -> l ->
	concat (map f l);

// Zip two lists together with a function
let zip_with = f -> l1 -> l2 ->
	if l1 == [] || l2 == [] then []
	else f (head l1) (head l2) : zip_with f (tail l1) (tail l2);

// Take first n elements
let take = n -> l ->
	if n <= 0 || l == [] then []
	else head l : take (n - 1) (tail l);

// Drop first n elements
let drop = n -> l ->
	if n <= 0 then l
	else if l == [] then []
	else drop (n - 1) (tail l);

// Take while predicate holds
let take_while = pred -> l ->
	if l == [] || not (pred (head l)) then []
	else head l : take_while pred (tail l);

// Drop while predicate holds
let drop_while = pred -> l ->
	if l == [] || not (pred (head l)) then l
	else drop_while pred (tail l);

// Sum of a list
let sum = l ->
	foldl (acc -> x -> acc + x) 0 l;

// Product of a list
let product = l ->
	foldl (acc -> x -> acc * x) 1 l;

// Avarage of a list
let avg = l ->
	(sum l) / (length l);

// Merge Sort
let merge = l1 -> l2 ->
	if l1 == [] then l2
	else if l2 == [] then l1
	else if head l1 < head l2 then
		head l1 : merge (tail l1) l2
	else
		head l2 : merge l1 (tail l2);

let sort = l ->
	if l == [] then l
	else if tail l == [] then l
	else
		merge
			(sort (take (length l / 2) l))
			(sort (drop (length l / 2) l));

// Check if list is sorted
let is_sorted = l ->
	if l == [] then true
	else if tail l == [] then true
	else head l <= head (tail l) && is_sorted (tail l);

let sum = l ->
    if l == [] then 0
    else (head l) + (sum (tail l));

let lines = s -> foldr (ch -> acc -> if ch == '\n' then "" : acc else (ch : head acc) : tail acc) [""] s;

let is_whitespace = ch -> ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r';

let trim = s -> reverse (drop_while is_whitespace (reverse (drop_while is_whitespace s)));

let parse_digit = ch ->
	if ch == '0' then 0
	else if ch == '1' then 1
	else if ch == '2' then 2
	else if ch == '3' then 3
	else if ch == '4' then 4
	else if ch == '5' then 5
	else if ch == '6' then 6
	else if ch == '7' then 7
	else if ch == '8' then 8
	else if ch == '9' then 9
	else 0;

let parse_int = s -> foldl (acc -> ch -> acc * 10 + (parse_digit ch)) 0 s;
