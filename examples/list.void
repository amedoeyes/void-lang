// Construct a list from range
let range = from -> to ->
	if from > to then []
	else from : range (from + 1) to;

// Fold left
let foldl = f -> acc -> l ->
	if l == [] then acc
	else foldl f (f acc (head l)) (tail l);

// Get the length of a list
let length = l ->
	foldl (acc -> _ -> acc + 1) 0 l;

// Reverse a List
let reverse = l ->
	foldl (acc -> x -> x : acc) [] l;

// Map list into a new list
let map = f -> l ->
	foldl (acc -> x -> acc ++ [f x]) [] l;

// Filter elements that satisfy a predicate
let filter = pred -> l ->
	foldl (acc -> x -> if pred x then acc ++ [x] else acc) [] l;

// Append two lists
let append = l1 -> l2 ->
	foldl (acc -> x -> acc ++ [x]) l2 l1;

// Concatenate a list of lists
let concat = ll ->
	foldl (acc -> l -> append acc l) [] ll;

// Check if any element satisfies a predicate
let any = pred -> l ->
	foldl (acc -> x -> acc || pred x) false l;

// Check if all elements satisfy a predicate
let all = pred -> l ->
	foldl (acc -> x -> acc && pred x) true l;

// Check if an element exists in a list
let elem = x -> l ->
	any (y -> y == x) l;

// Map list and then flatten it
let flat_map = f -> l ->
	concat (map f l);

// Zip two lists together with a function
let zip_with = f -> l1 -> l2 ->
	if l1 == [] || l2 == [] then []
	else f (head l1) (head l2) : zip_with f (tail l1) (tail l2);

// Take first n elements
let take = n -> l ->
	if n <= 0 || l == [] then []
	else head l : take (n - 1) (tail l);

// Drop first n elements
let drop = n -> l ->
	if n <= 0 then l
	else if l == [] then []
	else drop (n - 1) (tail l);
